# 数据结构
> 本章主要学习`基础算法`,`数据结构`和`复杂度`.  
> 参考至[web全栈体系](https://senior-frontend.pages.dev/)

## 复杂度
> 衡量算法的优劣，一般通过`耗费`的`时间资源`和`空间(内存)资源`.  
> 复杂度分为`时间`复杂度和`空间`复杂度。  
> 复杂度一般由`O()`表示，内部的值越大，表示复杂度越高。

### 时间复杂度
> 表示运行算法所`花费的时间`，因`变量`的变化而增加的`复杂度规律`(数量级)。   

### O(1)
> `常数级别`的时间复杂度
```js
const a = 1;
console.log(a);
// 表示当变量没有变化
```
### O(n)
> `自然数级别`的时间复杂度
```js
const n = 20;
for(let i=0; i<n; i++){
	// ...
}
// n的变化，会导致程序执行时间一起变化，呈自然数变化的规律。
```

### O(n^2)
> `指数级别`的时间复杂度  
```js
const n = 20;
for(let i=0; i<n; i++){
	for(let j=0; j<n; j++){
		// ...
	}
}

// 嵌套了2层循环，
// n的变化，会导致执行时间呈指数级别递增，
// 呈现指数级变化的规律。
```

### O(log2n)
> `对数级别`的时间复杂度  
> 在`O(n)`和`O(n2)`案例上，都是变量`i++`执行循环。  
> 当`基本变化规律`不是`增减`, 而是`乘数`变化时, 就是`对数级别数量级`
```js
for(let i=0; i<n; i *= 2){
	// ...
}
// 由于i++ 变为了 i*=2
// 其总的时间复杂度由 O(n) 缩减为了 O(log2n)
```

### 计算步骤
- 计算时间复杂度的步骤：
1. 找到`执行次数最多`的语句 
2. 计算语句执行次数的`数量级`
3. 用`大O`来表示结果
```js
let num = 0, num2 = 0;
for(let i=0; i<n; i *= 2){
	num +=1;
	for(let j=0; j<n; j++){
		// ...
		num2 +=1
	}
}

// 执行最多的是内部的num2 +=1
// 执行的数量级为 nlog2n
// 时间复杂度为 O(nlog2n)
```

### 计算规则
1. 当`n`无限趋近于无穷时，`1/n`趋向于0.
2. 加法规则: 当两个时间复杂度处于`同级`，相加时取`较大值`
3. 乘法规则: 当两个时间复杂度处于`嵌套级`，量级相乘
4. 只有`可运行`的语句，才会增加时间复杂度。
```js
for (let i=1; i<=n; i++){
	for (let j=1; j<=n; j++){
		console.log(1);
	}
}
// 以上的时间复杂度为  O(n2)

for(let x=1; x<n; x++){
	console.log(1);
}
// 以上的时间复杂度为O(n)

// 因此，总的时间复杂度为 O(n+n2) =>O(max(n,n2)) => O(n2)
```
### 空间复杂度
> 表示运行算法所`占用的空间`，因`变量`的变化而增加的`复杂度规律(数量级)`。

### O(1)
> `常数级别`，即`变量变化`并`没有导致`程序`占用的空间`发生变化。
```js
const a =10;
for(let i=0; i<n; i++){
	console.log(n)
}
for(let i=0; i<n; i++){
	for(let j=0; j<n; j++){
		console.log(n)
	}
}
// 以上3个, 空间复杂度均未为O(1)
```

### O(n)
> `自然数级别`，即`变量变化`会`导致`程序`占用的空间`递增。  
> 内存占用变化的规则呈`自然数级`现象。
```js
const arr = []
for(let i=0; i<n; i++){
	arr.push(i);
}
// 当i发生变化时，arr占用不断增大，并且与i的自然递增，有强相关。
```

### O(n^2)
> `指数级别`, 内存占用变化的规则呈`指数级`现象。
```js
const arr = []
for(let i=0; i<n; i++){
	arr[i] = i;
	for(let j=0; j<n; j++){
		arr[i][j] = i + j;
	}
}

// 当嵌套到j层时，外部的arr[i] = i; 呈n级别递增，
// 内部的arr[i][j] = i + j; 也呈n级别递增
// 因此一共是 n * n, 也就是O(n2)
```

### O(log2n)
> `对数级别`, 与`时间复杂度`的`O(log2n)`一样  
> 当`基本变化规律`不是`增减`, 而是`乘数`变化时,
```js
const arr = []
for(let i=0; i<n;i*=2){
	arr[i] = i
}
```

### 额外补充
> 时间和空间复杂度往往是`相互影响`的, 当一味的追究`时间复杂度`  
> 可能消耗更多的内存.


## 数据结构
### 栈
> 栈是指: 按一种`先进后出`的原则存储数据.   
> 想象一个`瓶子`装石头,往往先装入的,只有最后才能取出.  
> `栈`和`队列`在js中,经常用`数组模拟`

```js
// 用数组模拟栈
class Stack{
	constructor(){
		this.arr = []
	}
	addData(...data){
		this.arr.push(...data)
	}
	delData(){
		this.arr.pop()
	}
}

const stack = new Stack()
stack.addData(1,2,3,4,5)  //按 顺序挤入, 5最后挤入
stack.delData() //5被删除
console.log(stack.arr); //1,2,3,4
```

### 队列
> 队列是指: 按一种`先进先出`的原则存储数据.  
> 想象一个`漏斗`, 往里面倒入石头, 先倒入的先流出.  
```js
// 用数组模拟队列
class Queue{
	constructor(){
		this.arr = []
	}
	addData(...data){
		this.arr.push(...data)
	}
	delData(){
		this.arr.shift()
	}
}
const queue = new Queue()
queue.addData(1,2,3,4,5);  //1最先挤入
queue.delData(); //1被删除了
console.log(queue.arr);  //2,3,4,5
```


## 基础算法
> 更新中....